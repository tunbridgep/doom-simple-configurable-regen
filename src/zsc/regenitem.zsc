class SimpleRegenerator : inventory
{
	default
    {
		inventory.maxamount 1;
	}

    int previousHealth;
    int currentTicks;
    int displayTicks;
    int oldStartTics;
    bool startedRegen;

    void PlayConditionalSound(int soundlevel, string sound, int channel, float volume, bool stopsound = false)
    {
        if (regen_sounds >= soundlevel)
        {
            if (stopsound)
                owner.A_StopSound(channel);
            owner.A_StartSound(sound, channel, CHANF_UI|CHANF_OVERLAP, volume, 0, 0);
        }
    }

    void DoNoMercy()
    {
        let dawn = Dawn(owner);
        if (regen_no_mercy && dawn)
            dawn.mercyCooldown = dawn.MERCY_DAMAGE_COOLDOWN;
    }

    void DoDangerState()
    {
        let dawn = Dawn(owner);
        int health = owner.Health;

        if (dawn)
        {
            if (dawn.isDangerState && health > regen_danger_health)
                dawn.EndDangerState();
            else if (!dawn.isDangerState && health <= regen_danger_health)
                dawn.StartDangerState();
        }

    }

    //Set up the circular red bar that appears when regeneration is recharging
    void ResetChargeBar()
    { 
        class<Inventory> itemClass = 'RegenTics';

        //Replace the inventory item with a new one
        //because the display works based on maxamount
        let item = FindInventory(itemClass);
        if (item)
            item.Destroy();
        item = Inventory(Spawn(itemClass));
        item.maxAmount = regen_delay_start * 35.0;
        item.Touch(owner);
        console.printf("New Max Amount is: %d",item.maxAmount);

        //Now empty the bar
        owner.GiveInventory("RegenTics", 9999);
    }

    void DoRegen()
    {
        if (!startedRegen)
        {
            startedRegen = true;
            owner.GiveInventory("RegenActive", 1);
        
            //play the start sound
            PlayConditionalSound(1,"player/regen/active", CHAN_UI, 0.35);
        }
            
        //Play healing sound
        PlayConditionalSound(2,"player/regen/tick", CHAN_5, 0.7);
           
        //Display graphics
        UpdateHealIndicator();

        //Heal
        int heal = owner.health + regen_per_tick;
        if (heal > regen_max)
            heal = regen_max;

        owner.A_SetHealth(heal);

        //if we're finished, stop regenerating
        if (heal >= regen_max)
            StopRegen();
    
        currentTicks = 0;
    }

    void StopRegen()
    {
        if (startedRegen)
        {
            owner.TakeInventory("RegenActive", 1);
            PlayConditionalSound(1,"player/regen/complete", CHAN_AUTO, 0.7, true);
            startedRegen = false;
        }
        currentTicks = 0;
    }


    void UpdateHealIndicator()
    {
        Dawn(owner).HealTick(10);
    }

    override void DoEffect()
    {
        
        Super.DoEffect();
        if (owner)
        {
            //We need to convert our start delay and delay per tick from seconds to tics
            int regen_delay_start_tics = regen_delay_start * 35.0;
            int regen_delay_per_tick_tics = regen_delay_per_tick * 35.0;
            int health = owner.Health;
            if (health <= 0)
                return;

            if (owner.CheckInventory("HardcoreMode",1) && !regen_allow_hardcore) //no regeneration on hardcore (and no post on sundays)
                return;

            //Stop regeneration if we're above max health
            if (health >= regen_max)
            {
                owner.TakeInventory("HasLowHealth", 1);
                StopRegen();
                owner.GiveInventory("RegenTics",9999);
            }

            //If we took damage last frame, reset the timer
            else if (health < previousHealth)
                StopRegen();

            //Otherwise, we can regenerate
            else if (health < regen_max)
            {
                owner.GiveInventory("HasLowHealth", 1);

                //Check for regen
                if (currentTicks >= regen_delay_start_tics && !startedRegen)
                    DoRegen();
                else if (currentTicks >= regen_delay_per_tick_tics && startedRegen)
                    DoRegen();
                
                //add more to the charge bar slowly
                owner.TakeInventory("RegenTics",1);
            }

            //Handle danger state (red vignette and cries of pain)
            DoDangerState();

            //Update the health circle if our start delay was updated
            if (oldStartTics != regen_delay_start_tics)
                ResetChargeBar();

            //If we've removed mercy, set it to always be on cooldown
            DoNoMercy();

            previousHealth = owner.Health;
            currentTicks++;
            oldStartTics = regen_delay_start_tics;
        }
    }
}
